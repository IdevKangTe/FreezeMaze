<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
            var dx = [-1,1,0,0]; // 상하좌우
            var dy = [0,0,-1,1];

            var shortestPath = [];
            // Player의 위치에서부터 역으로 추적하여, 최단거리로 이동한 좌표들을 shortestPath 배열에 추가합니다.
            var curX = Player[0];
            var curY = Player[1];
            
            var map = [
                [1,1,1,1,1,1,1,1], 
                [1,1,0,0,0,1,0,1],
                [1,0,0,1,3,0,0,1],
                [1,1,0,0,0,1,1,1],
                [1,1,0,1,0,0,0,1],
                [1,1,0,1,0,1,0,1],
                [1,0,2,0,0,0,0,1],
                [1,1,1,1,1,1,1,1]
            ];
            var Player = [6,2]; // player 2
            var Monster = [2,4]; // monster 3

            var vis = [...map];
            vis[Player[0]][Player[1]] = 0;
            vis[Monster[0]][Monster[1]] = 0;      
            // 몬스터에서 플레이어까지의 최단거리            
            var count = 0;
            var queue = [[Monster[0], Monster[1]]];
            var chase = [];
            while(queue.length !==0){                
                var now = queue.shift()    
                var now_x = now[0];
                var now_y = now[1];
                if(now_x == Player[0] && now_y == Player[1]){                                          
                    break;    
                } 
                for(var i=0; i<4; i++){  // 상하좌우
                    var nx = now_x + dx[i];
                    var ny = now_y + dy[i];
                    if (vis[nx][ny]== 0){
                        vis[nx][ny] = vis[now_x][now_y]+1;
                        queue.push([nx, ny]);
                    }                    
                }                
            }
                
                
            // console.log(vis);
            // console.log(vis[Player[0]][Player[1]]);
            


while (curX != Monster[0] || curY != Monster[1]) {
    shortestPath.unshift([curX, curY]); // 배열의 맨 앞에 좌표 추가
    for (var i = 0; i < 4; i++) {
        var nx = curX + dx[i];
        var ny = curY + dy[i];
        if (vis[nx][ny] == vis[curX][curY] - 1) {
            curX = nx;
            curY = ny;
            break;
        }
    }
}

        console.log(shortestPath);
        //위 코드를 실행하면, Monster에서 Player까지 최단거리로 이동한 좌표들의 목록이 출력됩니다. 이 배열은 shortestPath 변수에 저장되어 있습니다.




    </script>
</body>
</html>